/*
 * Danish Data Portal - HPC API
 *
 * A Web API for HPC centers to communicate with the Danish Data Portal to manage access and data transfers
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"fmt"
	"time"
	"net/http"
	"encoding/json"
	"strings"
	"strconv"
)
type Data map[string]any

var messageCount int = 0

var queue []int

func generateMessage(i int) map[string]any{
	now := time.Now()
	dataMap := make(map[string]any)
	messageCount += 1
	var messageType HPCMessageTypeEnum
	switch i{
		case 0:
		messageType = CREATE_PROJECT
		dataMap["ProjectNo"] = 1337 //Is 42 funnier?

		case 1:
		messageType = DELETE_PROJECT
		dataMap["ProjectNo"] = 1337 //Maybe 666?

		case 2:
		messageType = CREATE_PROJECT_ACCESS

		dataMap["ProjectNo"] = 1337
		dataMap["AccessIdentifier"] = "Test"

		case 3:
		messageType = DELETE_PROJECT_ACCESS
		dataMap["AccessIdentifier"] = "Test"

		case 4:
		messageType = DISABLE_PROJECT_ACCESS
		dataMap["AccessIdentifier"] = "Test"

		case 5:
		messageType = ENABLE_PROJECT_ACCESS
		dataMap["AccessIdentifier"] = "Test"

		case 6:
		messageType = RESET_PASSWORD
		dataMap["AccessIdentifier"] = "Test"

		case 7:
		messageType = DATA_DELIVERY_READY

		dataMap["DataDeliveryId"] = "DeliveryId"
		dataMap["ProjectNo"] = 1337

		var filesMap []map[string]string
		file := make(map[string]string)
		file["FileId"] = "File"
		file["FileSize"] = "1"
		file["FileChecksum"] = "0"
		filesMap =append(filesMap, file)

		dataMap["Files"] = filesMap

		case 8:
		messageType = DELETE_DATA_FILE
		dataMap["FileId"] = "File"

		default:
		messageType = RETURN_DATA_FILE
		dataMap["FileId"] = "File"

	}
	message := make(map[string]any)
	message["messageId"] = (messageCount-1)
	message["messageType"] = messageType
	message["timestamp"] = now.String()
	message["data"] = dataMap
	return message
}

var MESSAGELISTORDERING []int = []int{0,2,4,5,6,7,8,9,3,1}

func getMessages() []Data{
	var data []Data
	for i := 0; i < len(MESSAGELISTORDERING); i++ {
		queue = append(queue, messageCount)
		data = append(data, generateMessage(MESSAGELISTORDERING[i]))
	}
	return data
}

func MessagesGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(getMessages())
	fmt.Println(queue)
}

func MessagesIdPatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	messageIdString := strings.Split(r.RequestURI, "/messages/")[1]
	messageId, err := strconv.Atoi(messageIdString)
	if err != nil {
		fmt.Println("Error converting the following messageId to an integer: ", err)
	}

	//Look only for the first message in the queue
	if(queue != nil && queue[0] == messageId){
		w.WriteHeader(http.StatusOK)
		queue = queue[1:]
	} else {
		w.WriteHeader(http.StatusNotFound)
	}
	fmt.Println(queue)
}

func MessagesPatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNotImplemented)
}
